#!/usr/bin/perl

# Copyright (C) 2012-2013 Trizen <echo dHJpemVueEBnbWFpbC5jb20K | base64 -d>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Original author: dircha
# See: http://bbs.archbang.org/viewtopic.php?id=1589

# Rewritten by: Trizen
# License: GPLv3
# Date: 29 December 2012
# Latest edit: 25 March 2013
# http://trizen.googlecode.com

# ---------------------------------------------------------
# Recursively browse filesystem through openbox3 pipe menus
# ---------------------------------------------------------

#use 5.014;
#use strict;
#use warnings;

my $pkgname = 'obbrowser';
my $version = 0.02;

our $CONFIG;

my $home_dir =
     $ENV{HOME}
  || $ENV{LOGDIR}
  || (getpwuid($<))[7]
  || `echo -n ~`;

my $config_dir        = "$home_dir/.config/obbrowser";
my $config_file       = "$config_dir/config.pl";
my $icons_db_filename = "$config_dir/icons.db";

if (not -d $config_dir) {
    require File::Path;
    File::Path::make_path($config_dir)
      or die "Can't create dir `$config_dir': $!";
}

sub print_usage {
    print <<"USAGE";
usage: $0 [dir]

** To use this script with Openbox, insert the following
   line into your menu.xml file:

    <menu id="FILE_BROWSER" label="Disk" execute="$0"/>

** If you're using obmenu-generator, you can add a 'raw' entry
   in ~/.config/obmenu-generator/schema.pl with the above XML line,
   like this: {raw => '<menu id= ... />'}

** For more settings, please see the configuration file:
   $config_file

** After you change the icon theme, you should delete the icon database
   generated by this script: $icons_db_filename

USAGE
    exit;
}

if (@ARGV && $ARGV[0] ~~ ['-h', '--help']) {
    print_usage();
}

my $config_documentation = <<"EOD";
#!/usr/bin/perl

# $pkgname - configuration file
# This file is updated automatically every time when is needed.
# Any additional comment and/or indentation will be lost.

=for comment

file_manager (STRING)
    - command to your file manager for opening files and directories.

with_icons (BOOL)
    - a true value will make the script to use icons for files and dirs.
    - this option may be slow, depending on your system configuration.

icon_dirs_first (ARRAY_REF) ['dir', ...]
    - when looking for icons, look in this directories first.

icon_dirs_last (ARRAY_REF) ['dir', ...]
    - when looking for icons, look in this directories last.

dirs_first (BOOL)
    - a true value will make the script to order directories before files.

gtk_rc_filename (STRING)
    - path to your Gtk RC file.
    - this file is used to get the current icon theme name.
    - if the value is undefined (undef), it assumes '$home_dir/.gtkrc-2.0'
    - if you're using Gtk3, change its value to: '$home_dir/.config/gtk-3.0/settings.ini'

VERSION (NUMBER)
    - version of $pkgname.

=cut

EOD

my %CONFIG = (
              file_manager    => 'pcmanfm',
              start_path      => $home_dir,
              icon_dirs_first => undef,
              icon_dirs_last  => undef,
              dirs_first      => 0,
              with_icons      => 1,
              gtk_rc_filename => undef,
              VERSION         => $version,
             );

sub dump_configuration {
    require Data::Dump;
    open my $config_fh, '>', $config_file
      or die "Can't open file '${config_file}' for write: $!";
    my $dumped_config = q{our $CONFIG = } . Data::Dump::dump(\%CONFIG);
    print $config_fh $config_documentation, $dumped_config;
    close $config_fh;
}

if (not -e $config_file or -z _) {
    dump_configuration();
}

require $config_file;    # load the configuration file

my @valid_keys = grep exists $CONFIG{$_}, keys $CONFIG;
@CONFIG{@valid_keys} = @{$CONFIG}{@valid_keys};

if ($CONFIG{VERSION} != $version) {
    $CONFIG{VERSION} = $version;
    dump_configuration();
}

my $ld_obj;
if ($CONFIG{with_icons}) {

    require Linux::DesktopFiles;
    $Linux::DesktopFiles::VERSION >= 0.07 || die "Update Linux::DesktopFiles to a newer version! (requires >=0.07)\n";

    $ld_obj = Linux::DesktopFiles->new(
                                       full_icon_paths         => 1,
                                       skip_svg_icons          => 1,
                                       use_only_my_icon_dirs   => 1,
                                       use_current_theme_icons => 1,
                                       home_dir                => $home_dir,
                                       with_icons              => $CONFIG{with_icons},
                                       icon_dirs_first         => $CONFIG{icon_dirs_first},
                                       icon_dirs_last          => $CONFIG{icon_dirs_last},
                                       gtk_rc_filename         => $CONFIG{gtk_rc_filename},
                                       icon_db_filename        => ($CONFIG{with_icons} ? $icons_db_filename : undef),
                                      );
}

{
    my $path = @ARGV ? shift() : $CONFIG{start_path};

    my (%alias, %icons, @dirs, @files);
    opendir(my $dir_h, $path) or warn "$0: Can't open dir `$path': $!\n";
    foreach my $file (readdir $dir_h) {

        next if chr ord $file eq q{.};    # skip the hidden files

        if ($CONFIG{with_icons}) {

            if (-d "$path/$file") {
                push @dirs, [$file, $icons{'inode-directory'} ||= $ld_obj->get_icon_path('inode-directory')];
                next;
            }

            require File::MimeInfo;       # File::MimeInfo::Magic is better, but slower!
            my $mime_type = File::MimeInfo::mimetype("$path/$file");
            $mime_type =~ tr{/}{-};
            $mime_type = $alias{$mime_type} if exists $alias{$mime_type};

            {
                my $type = $mime_type;
                while (1) {
                    if ($icons{$type} ||= $ld_obj->get_icon_path($type)) {
                        $alias{$mime_type} = $type;
                        $mime_type = $type;
                        last;
                    }
                    elsif ($icons{"gnome-mime-$type"} ||= $ld_obj->get_icon_path("gnome-mime-$type")) {
                        $alias{$mime_type} = "gnome-mime-$type";
                        $mime_type = "gnome-mime-$type";
                        last;
                    }
                    $type =~ s{.*\K[[:punct:]]\w++$}{} || last;
                }
            }

            if (!$icons{$mime_type}) {
                my $type = $mime_type;
                while (1) {
                    $type =~ s{^application-x-\K.*?-}{} || last;
                    $icons{$type} ||= $ld_obj->get_icon_path($type);
                    $icons{$type} && do { $alias{$mime_type} = $type; $mime_type = $type; last };
                }
            }
            push @files, [$file, $icons{$mime_type} ||= $ld_obj->get_icon_path('unknown')];
        }
        else {
            push +(-d "$path/$file" ? \@dirs : \@files), [$file, ''];
        }

    }
    closedir $dir_h;

    my $generated_menu = "<openbox_pipe_menu>\n";
    my $esc_path       = esc_str($path);

    # "Browse here..." lauches this dir
    $generated_menu .= <<"BROWSE_ITEM";
  <item label="Browse here...">
    <action name="Execute">
      <execute>$CONFIG{file_manager} &quot;${\quot_escape($esc_path)}&quot;</execute>
    </action>
  </item>
 <separator/>
BROWSE_ITEM

    my @calls = ([\&mk_file_elem => \@files], [\&mk_dir_elem => \@dirs]);

    if ($CONFIG{dirs_first}) {
        @calls = reverse(@calls);
    }

    foreach my $call (@calls) {
        $generated_menu .= $call->[0]->($esc_path, esc_str($_->[0]), $_->[1])
          for sort { lc $a->[0] cmp lc $b->[0] } @{$call->[1]};
    }

    ++$|;
    print $generated_menu, "</openbox_pipe_menu>\n";
    exit;
}

sub esc_str {
    $_[0] =~ tr/&"// ? ($_[0] =~ s/&/&amp;/gr =~ s/"/&quot;/gr) : $_[0];
}

sub quot_escape {
    $_[0] =~ s/(&quot;)/\\$1/gr;
}

sub mk_dir_elem {
    <<"MENU_ID"
<menu id="$_[0]/$_[1]" label="$_[1]" icon="$_[2]" execute="\Q$0\E &quot;${\quot_escape("$_[0]/$_[1]")}&quot;"/>
MENU_ID
}

sub mk_file_elem {
    <<"ITEM"
<item label="$_[1]" icon="$_[2]"><action name="Execute"><execute>$CONFIG{file_manager} &quot;${\quot_escape("$_[0]/$_[1]")}&quot;</execute></action></item>
ITEM
}
